#!/usr/bin/env -S uv run --script
#
# Author: Jan Larres <jan@majutsushi.net>
# License: MIT/X11
#
# Inspired by https://github.com/hickford/git-credential-azure
# and https://github.com/git-ecosystem/git-credential-manager/blob/main/src/shared/Microsoft.AzureRepos/AzureReposHostProvider.cs
#
# /// script
# dependencies = ["keyring", "msal", "requests"]
# ///
#


import argparse
import contextlib
import datetime as dt
import logging
import os
import re
import subprocess
import sys
from dataclasses import dataclass

import keyring
import requests
from msal import PublicClientApplication

# Client application ID for accessing Azure DevOps.
# https://github.com/git-ecosystem/git-credential-manager/blob/8c430c9484c90433ab30c25df7fc1005fe2f4ba4/src/shared/Microsoft.AzureRepos/AzureDevOpsConstants.cs#L15
# magic https://developercommunity.visualstudio.com/t/non-interactive-aad-auth-works-for-visual-studio-a/387853
CLIENT_ID = "872cd9fa-d31f-45e0-9eab-6e460a02d1f1"

# Authority (identity provider) for accessing Azure DevOps.
# https://learn.microsoft.com/en-us/azure/active-directory/develop/msal-client-application-configuration#authority
AUTHORITY = "https://login.microsoftonline.com/organizations"

# Scope for accessing Azure DevOps.
# https://learn.microsoft.com/en-us/azure/devops/organizations/accounts/manage-personal-access-tokens-via-api?view=azure-devops
SCOPE = "499b84ac-1321-427f-aa17-267ca6975798/.default"

# https://learn.microsoft.com/en-us/rest/api/azure/devops/tokens/pats/create?view=azure-devops-rest-7.1&tabs=HTTP
PAT_URL = "https://vssps.dev.azure.com/{organization}/_apis/tokens/pats?api-version=7.1-preview.1"

GIT_CONTEXT_PREFIX = "azrepos:org/"


logging.basicConfig(format="[azure] %(levelname)s: %(message)s", level=logging.INFO)
log = logging.getLogger(__name__)


@dataclass
class Token:
    token: str
    expiry: int
    refresh_token: str

    def __str__(self) -> str:
        return (
            "Token("
            + ",".join(
                [
                    f"token={self.token[:3]}***{self.token[-3:]}",
                    f"expiry={self.expiry}({dt.datetime.fromtimestamp(self.expiry).isoformat()})",  # noqa: DTZ006
                    f"refresh_token={self.refresh_token[:3]}***{self.refresh_token[-3:]}",
                ]
            )
            + ")"
        )


@dataclass()
class InputArgs:
    host: str
    protocol: str
    path: str
    username: str | None
    refresh_token: str | None
    capabilities: list[str]
    state: list[str]
    wwwauth: list[str]


@dataclass
class OutputArgs:
    username: str
    token: Token

    def __str__(self) -> str:
        output = [
            f"username={self.username}",
            f"password={self.token.token}",
            f"password_expiry_utc={self.token.expiry}",
        ]
        if self.token.refresh_token is not None:
            output.append(f"oauth_refresh_token={self.token.refresh_token}")
        return "\n".join(output)


def main(args: argparse.Namespace) -> None:
    if args.verbose or os.getenv("AZURE_TRACE", "0") != "0":
        log.setLevel(logging.DEBUG)

    stdin = sys.stdin.read()
    log.debug("Received command: %s\nwith input:\n%s", args.command, stdin)
    input_args = parse_input(stdin)
    if input_args is None:
        return

    org = input_args.path.split("/")[0]
    username = get_git_option(f"credential.{GIT_CONTEXT_PREFIX + org}.username")
    if username is not None:
        input_args.username = username

    match args.command:
        case "get":
            fill_credential(input_args, org)
        case "store":
            # Not implemented
            pass
        case "erase":
            erase_stored_credential(input_args, org)


def fill_credential(input_args: InputArgs, org: str) -> None:
    token = get_stored_credential(input_args, org)
    if token is not None:
        input_args.refresh_token = token.refresh_token

    now = dt.datetime.now(dt.timezone.utc)
    if token is not None and token.expiry > now.timestamp():
        log.debug("Found valid stored token")
        output = OutputArgs(org, token)
    else:
        log.debug("Getting OAuth token")
        output = get_oauth_token(input_args, org, now)
        if output is None:
            return

    log.debug("Output:\n%s", output)
    print(output)


def get_oauth_token(
    input_args: InputArgs, org: str, now: dt.datetime
) -> OutputArgs | None:
    authority = get_authority(org)
    if authority is None:
        return None

    app = PublicClientApplication(CLIENT_ID, authority=authority)
    token = get_access_token(app, input_args, now)
    if token is None:
        return None

    store_credential(input_args, org, token)
    return OutputArgs(org, token)


def get_access_token(
    app: PublicClientApplication, input_args: InputArgs, now: dt.datetime
) -> Token | None:
    result = {}
    if input_args.refresh_token is not None:
        log.debug("Using refresh token to acquire access token")
        result = app.acquire_token_by_refresh_token(
            input_args.refresh_token, scopes=[SCOPE]
        )
        if "error" in result:
            log.debug(result.get("error"))
            log.debug(result.get("error_description"))
            log.debug(result.get("correlation_id"))
        if "access_token" in result:
            log.debug("Got access token from refresh token")

    if "access_token" not in result:
        result = app.acquire_token_interactive(
            scopes=[SCOPE], login_hint=input_args.username
        )
        if "access_token" not in result:
            log.error(result.get("error"))
            log.error(result.get("error_description"))
            log.error(result.get("correlation_id"))
            return None

    valid_to = now + dt.timedelta(seconds=result["expires_in"])
    token = Token(
        result["access_token"], int(valid_to.timestamp()), result["refresh_token"]
    )
    # token = Token(
    #     result["access_token"],
    #     int((now + dt.timedelta(minutes=5)).timestamp()),
    #     result["refresh_token"],
    # )
    log.debug("Got token: %s", token)
    return token


def get_stored_credential(input_args: InputArgs, org: str) -> Token | None:
    url = f"{input_args.protocol}://{input_args.host}"
    credential: str | None = keyring.get_password(url, org)
    if credential is not None:
        token_str, expiry, refresh_token = credential.split(":")
        token = Token(token_str, int(expiry), refresh_token)
        log.debug("Found stored token: %s", token)
        return token
    return None


def store_credential(input_args: InputArgs, org: str, token: Token) -> None:
    url = f"{input_args.protocol}://{input_args.host}"
    log.debug("Storing token %s for URL %s and org %s", token, url, org)
    credential = f"{token.token}:{token.expiry}:{token.refresh_token}"
    keyring.set_password(url, org, credential)


def erase_stored_credential(input_args: InputArgs, org: str) -> None:
    url = f"{input_args.protocol}://{input_args.host}"
    log.debug("Erasing credential for URL %s and org %s", url, org)
    with contextlib.suppress(keyring.errors.PasswordDeleteError):
        keyring.delete_password(url, org)


def get_authority(org: str) -> str | None:
    authority_opt = f"credential.{GIT_CONTEXT_PREFIX + org}.azureAuthority"
    authority = get_git_option(authority_opt)
    if authority is not None:
        return authority

    r = requests.head("https://dev.azure.com/" + org, timeout=10)
    for header in r.headers["www-authenticate"].split(","):
        if match := re.search("authorization_uri=(?P<authority>.+)", header.strip()):
            authority = match["authority"]
            log.debug("Found authority: %s", authority)

            try:
                log.debug("Caching authority in Git config")
                subprocess.run(  # noqa: S603
                    ["git", "config", "set", "--global", authority_opt, authority],  # noqa: S607
                    check=True,
                    text=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                )
            except subprocess.CalledProcessError as e:
                log.debug("Failed to cache authority in Git config: %s", e.stdout)

            return authority

    return None


def get_git_option(option: str) -> str | None:
    try:
        value = subprocess.run(  # noqa: S603
            ["git", "config", "get", option],  # noqa: S607
            check=True,
            text=True,
            stdout=subprocess.PIPE,
        ).stdout.strip()
    except subprocess.CalledProcessError as e:
        log.debug("Error getting Git option: %s", e)
        value = None
    log.debug("Git option %s = %s", option, value)
    return value


def parse_input(input_args: str) -> InputArgs | None:  # noqa: C901
    host = None
    protocol = None
    username = None
    path = None
    refresh_token = None
    capabilities = []
    state = []
    wwwauth = []

    # Split only on \n because of https://flatt.tech/research/posts/clone2leak-your-git-credentials-belong-to-us/
    for line in input_args.strip().split("\n"):
        log.debug("Parsing line: %s", line)
        key, val = line.strip().split("=", maxsplit=1)
        if key == "host":
            host = val
        elif key == "protocol":
            protocol = val
        elif key == "path":
            path = val
        elif key == "username":
            username = val
        elif key == "oauth_refresh_token":
            refresh_token = val
        elif key == "capability[]":
            capabilities.append(val)
        elif key == "state[]":
            state.append(val)
        elif key == "wwwauth[]":
            wwwauth.append(val)

    if host != "dev.azure.com" or protocol != "https" or path is None:
        return None

    return InputArgs(
        host, protocol, path, username, refresh_token, capabilities, state, wwwauth
    )


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Git credential helper for ADO")
    parser.add_argument("command", help="the credential command")
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        default=False,
        help="increase output verbosity",
    )
    return parser.parse_args()


if __name__ == "__main__":
    main(parse_args())
